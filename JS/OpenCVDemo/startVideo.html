<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="description"
    content="WebRTC code samples">
  <meta name="viewport"
    content="width=device-width, user-scalable=yes, initial-scale=1, maximum-scale=1">
  <meta name="mobile-web-app-capable"
    content="yes">
  <title>Document</title>
  <style>
    .control {
      margin-bottom: 3px;
    }

    button {
      display: inline-block;
      color: #fff;
      background-color: #337ab7;
      border-color: #2e6da4;
      padding: 6px 12px;
      margin-bottom: 0;
      font-size: 14px;
      font-weight: bold;
      text-align: center;
      white-space: nowrap;
      vertical-align: middle;
      -ms-touch-action: manipulation;
      touch-action: manipulation;
      cursor: pointer;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      background-image: none;
      border: 1px solid transparent;
      border-radius: 4px;
    }

    canvas,
    img,
    video {
      border: 1px solid black;
    }
  </style>
</head>

<body>
  <h2>Hello OpenCV.js</h2>
  <p id="status">OpenCV.js is loading...</p>
  <div class="control">
    <button id="startAndStop">Start</button>
  </div>
  <video id="videoInput"
    width="520"
    height="340"></video>
  <canvas id="canvasOutput"
    width="520"
    height="340"></canvas>

  <script src="util.js"></script>
  <script type="text/javascript">
    let utils = new Utils('errorMessage')
    utils.loadOpenCv(() => {
      startAndStop.removeAttribute('disabled')
      utils.onOpenCvReady()
      exeCode()
    })

    let streaming = false
    let videoInput = document.getElementById('videoInput')
    let startAndStop = document.getElementById('startAndStop')
    let canvasOutput = document.getElementById('canvasOutput')
    let canvasContext = canvasOutput.getContext('2d')

    startAndStop.addEventListener('click', () => {
      if (!streaming) {
        utils.startCamera('qvga', onVideoStarted, 'videoInput')
      } else {
        utils.stopCamera()
        onVideoStopped()
      }
    })

    function exeCode() {
      let video = document.getElementById('videoInput')
      let src = new cv.Mat(video.height, video.width, cv.CV_8UC4)
      let dst = new cv.Mat(video.height, video.width, cv.CV_8UC1)
      let cap = new cv.VideoCapture(video)

      const FPS = 30

      function processVideo() {
        try {
          if (!streaming) {
            // clean and stop.
            src.delete()
            dst.delete()
            return
          }
          let begin = Date.now()
          // start processing.
          cap.read(src)
          cv.cvtColor(src, dst, cv.COLOR_RGBA2GRAY)
          cv.imshow('canvasOutput', dst)
          // schedule the next one.
          let delay = 1000 / FPS - (Date.now() - begin)
          setTimeout(processVideo, delay)
        } catch (err) {
          utils.printError(err)
        }
      }

      // schedule the first one.
      setTimeout(processVideo, 0)
    }

    function onVideoStarted() {
      streaming = true
      startAndStop.innerText = 'Stop'
      videoInput.width = videoInput.videoWidth
      videoInput.height = videoInput.videoHeight
      exeCode()
    }

    function onVideoStopped() {
      streaming = false
      canvasContext.clearRect(0, 0, canvasOutput.width, canvasOutput.height)
      startAndStop.innerText = 'Start'
    }
  </script>
</body>

</html>